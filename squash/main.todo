New version:
  ✔ Find a way to prove compatibility of seq (with Id and not conversion) @done(2016-05-31 16:21) @project(New version)
  ✔ Maybe some transport in validity (eg. elim-eq) @done(2016-05-31 14:25) @project(New version)
  ✔ Transports may still be needed as we are using substitutions @done(2016-05-31 16:16) @project(New version)
    ✔ We could remove the substitution relation and only instantiate (couldn't we?) @done(2016-05-31 15:17) @project(New version)
  ✘ Function injectivity requires a substitution for T' @cancelled(2016-05-31 16:27) @project(New version)
  ✔ Or we could remove dependecy in injectivity @done(2016-06-01 10:49) @project(New version)
  ✔ Fix inversion @done(2016-06-01 10:49) @project(New version)
  ☐ We can probably remove the first line of validity (and then remove injectivity of function type)
  ✔ Fundamental theorem doesn't need proof when return type is definite (in most cases) @done(2016-06-01 11:29) @project(New version)
  ✔ Are substitutions needed? @done(2016-06-01 14:55) @project(New version)
  ✔ Shouldn't seq be neutral? (or handle it in the elim whr) @done(2016-06-02 10:15) @project(New version)

New definition of |><| for Id:
  ☐ We need something that will allow J equality to be deduced
  ☐ Handle refl equality
  ☐ Handle seq equality

Problem with the substitution judgement:
  ✔ Change it again to ask conversion and |><| seperately @done(2016-06-01 16:25) @project(Problem with the substitution judgement)
  ✔ Adapt PER @done(2016-06-01 16:26) @project(Problem with the substitution judgement)
  ✔ Adapt validity PER @done(2016-06-01 16:28) @project(Problem with the substitution judgement)
  ✔ Adapt function type injectivity @done(2016-06-01 16:29) @project(Problem with the substitution judgement)
  ✔ Adapt context satisfiable @done(2016-06-01 16:29) @project(Problem with the substitution judgement)
  ✔ Adapt beta validity @done(2016-06-01 16:32) @project(Problem with the substitution judgement)
  ✔ Adapt eta validity @done(2016-06-01 16:36) @project(Problem with the substitution judgement)

New constraint for |><| for Pi:
  ✔ Add that u and u' are also convertible @done(2016-06-01 16:47) @project(New constraint for |><| for Pi)
  ☐ Adapt type conversion
  ✔ Adapt validity of eta @done(2016-06-01 16:49) @project(New constraint for |><| for Pi)
  ✔ Remove the transport now that convertible @done(2016-06-01 17:33) @project(New constraint for |><| for Pi)
  ✔ Adapt eta @done(2016-06-01 17:35) @project(New constraint for |><| for Pi)
  ✔ Adapt lambda equality @done(2016-06-01 17:39) @project(New constraint for |><| for Pi)
  ✔ Fix valiidty of application @done(2016-06-01 17:41) @project(New constraint for |><| for Pi)

New substitution judgement:
  ✔ Define it @done(2016-06-01 15:07) @project(New substitution judgement)
  ✔ Prove it is a PER @done(2016-06-01 15:10) @project(New substitution judgement)
  ✔ Adapt validity is a PER proof @done(2016-06-01 15:14) @project(New substitution judgement)
  ✔ Adapt function type injectivity @done(2016-06-01 15:18) @project(New substitution judgement)
  ✔ Adapt context satisfiable @done(2016-06-01 15:19) @project(New substitution judgement)
  ✔ Adapt beta validity @done(2016-06-01 15:23) @project(New substitution judgement)
  ✔ Adapt eta validity @done(2016-06-01 15:44) @project(New substitution judgement)
  ✔ Complete validity of lambda @done(2016-06-01 16:52) @project(New substitution judgement)
  ✔ Adapt elim reduction @done(2016-06-01 16:57) @project(New substitution judgement)
  ✔ Adapt elim equality @done(2016-06-01 17:01) @project(New substitution judgement)
  ✔ Complete validity of application @done(2016-06-01 17:41) @project(New substitution judgement)
  ☐ Complete J equality
  ☐ Adapt J reduction

New definiton of |><| for Pi:
  ✔ New definition @done(2016-06-01 14:17) @project(New definiton of |><| for Pi)
  ✔ Adapt eta @done(2016-06-01 14:37) @project(New definiton of |><| for Pi)
  ✔ lambda compatibility @done(2016-06-01 16:52) @project(New definiton of |><| for Pi)
  ✔ ⇒ We need to handle convertible substitutions for validity @done(2016-06-01 15:16) @project(New definiton of |><| for Pi)
  ☐ Deduce J and application compatibility
  ☐ Adapt type conversion

Fundamental theorem:
  ☐ J compatibility
  ✔ J beta @done(2016-06-01 13:15) @project(Fundamental theorem)
  ✔ application compatibility @done(2016-06-01 17:41) @project(Fundamental theorem)
  ☐ check validity of the type in application compatibility
  ✔ conversion rule @done(2016-06-01 13:34) @project(Fundamental theorem)

Embedding:
  ☐ Can the proof be adapted to handle the resizing for embedding?

Concerns:
  ☐ Is recursive call necessary on bowtie?
  ☐ Why doesn't it work with Type in Type?

＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
Archive:
  ✔ Add the guard to elim rules (T not a sort) @done(2016-05-30 11:45) @project(New version)
  ✔ Remove Sigma from logical relation @done(2016-05-30 12:09) @project(New version)
  ✔ Fix the proof accordingly (just say that since T is not a sort, we only need a proof of equality) @done(2016-05-31 10:10) @project(New version)
  ✔ Remove definitional equality for squash (it doesn't work with application) @done(2016-05-31 11:09) @project(New version)
  ✔ Add an operator to state said equality @done(2016-05-31 10:14) @project(New version)
  ✔ Use irrelevance to treat both squash cases for (S) without recursive call @done(2016-05-31 11:35) @project(Ideas to Assess)
  ✘ Only accept ||A|| as whnf, that is, reduction goes under squash @cancelled(2016-05-31 11:35) @project(Ideas to Assess)
  ✘ This previous idea would have probably been better with ||N|| only, perhaps it would be ideal to fonctorize the squash? @cancelled(2016-05-31 11:35) @project(Ideas to Assess)
  ✔ Is the definition of Squash space ok? @done(2016-05-31 11:35) @project(Things to Check)
  ✔ The fundamental theorem really holds without need for a proof @done(2016-05-31 11:35) @project(Things to Check)
  ✔ Type constructor discrimination @done(2016-05-31 11:35) @project(Things to Check)
  ✔ Is our definiton of (S) for equality suitable? @done(2016-05-31 11:35) @project(Things to Check)
  ✘ Lemmata for constructor injectivity (sigma, equality, squash) @cancelled(2016-05-31 11:33) @project(Things to Add (Maybe))
  ✘ Validity of beta/eta/constructor equality for sigma and identity @cancelled(2016-05-31 11:33) @project(Things to Do)
  ✔ Validity of elim reduction @done(2016-05-15 12:28) @project(Things to Do)
  ✔ Validity of squash irrelevance @done(2016-05-15 12:36) @project(Things to Do)
  ✘ Sigma / Indentity type injectivity @cancelled(2016-05-31 11:34) @project(Things to Do)
  ✔ Complete consistency proof @done(2016-05-15 16:20) @project(Things to Do)
  ✔ Complete box/box case of elim equality validity @done(2016-05-31 11:34) @project(Things to Do)
  ✔ Complete box/wne case of elim equality validity @done(2016-05-31 11:34) @project(Things to Do)
  ✔ Complete wne/wne case of elim equality validity @done(2016-05-31 11:34) @project(Things to Do)
  ✔ Treat equality in (S) @done(2016-05-16 10:14) @project(Things to Do)
  ✘ Validity proof for elim didn't use the h to ensure everything went fine @cancelled(2016-05-15 20:31) @project(Concerns) @why(Validity of elim equality lifts that concern)
  ✘ It doesn't seem possible to turn a proof of equality into an actual one in the model @cancelled(2016-05-31 11:34) @project(Concerns)
