\documentclass[11pt]{article}

% Font
% \renewcommand{\familydefault}{\sfdefault}
% \usepackage{helvet}
% \usepackage[sfdefault,light]{roboto}

\usepackage[T1]{fontenc} %
% \usepackage[latin1]{inputenc} %
\usepackage[utf8]{inputenc} %
% \usepackage[applemac]{inputenc} %
% \usepackage{a4wide} %

% \setlength{\parskip}{0.3\baselineskip}

\usepackage{amsmath, amssymb, amsfonts, stmaryrd}
\usepackage{mathrsfs}
\usepackage{amsthm}
\usepackage{bm}
\usepackage{pifont}

% Add some colors
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{hyperref}
\hypersetup{
 linktocpage,
 colorlinks,
 citecolor=BlueViolet,
 filecolor=red,
 linkcolor=Blue,
 urlcolor=BrickRed
}

% NTH
\usepackage[super]{nth}

% For EPS figures
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{wrapfig}

% Theorems
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}%[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem*{note}{Note}
\newtheorem{definition}[theorem]{Definition}

\theoremstyle{remark}
\newtheorem*{example}{Example}

% Meta comment
\newcommand\meta[1]{\noindent\textcolor{blue}{\emph{#1}}}

% Include the macro file
\input{macros}

\begin{document}

\title{Justifying Resizing Rules in HoTT \\
\small{Through an interpretation of extensional type theory into an intensional
one}}

\author{Théo Winterhalter, Nicolas Tabareau (ASCOLA, LINA)}

\date{\nth{5} of September, 2016}

\maketitle

\pagestyle{empty} %
\thispagestyle{empty}

%% Attention: pas plus d'un recto-verso!
% Ne conservez pas les questions


\subsection*{The general context}
% What is it about ? Where does it come from ?
% What is the state of the art in this area ?
Homotopy Type Theory (HoTT for short) is a new domain that aims to offer a new
axiomatisation of mathematics that allows to consider objects up to isomorphisms
(as a result of the univalence axiom which allows to derive an equality between
isomorphic types).
The underlying theory thus develops a lot of notions related to equality and its
treatment, in particular it theorises about equalities between equalities that
are often considered to be trivial as they are in Set Theory.

\subsection*{The research problem}

% What is the question that you studied ?
% Why is it important, what are the applications/consequences ?
% Is it a new problem ?
% If so, why are you the first researcher in the universe who consider it ?
% If not, why did you think that you could bring an original contribution ?
In type theory, and thus in proof assistants such as Coq~\cite{coq:manual} or
Agda~\cite{norell2007towards}, in order to avoid paradoxes \emph{à la} Russel,
we have to establish a hierarchy of universes (the types of types). Without it,
it would be possible to prove \emph{false} in Coq for instance
\cite{coquand:typetype}.
Nevertheless, the typing rules dealing with universes are purely syntactical
and can be seen as rough approximations to preserve consistency.
They can be annoying for the user and we can legitimately wonder whether we
can alleviate theses restrictions in some specific cases.

Stated by Vladimir Voevodsky~\cite{vv:resizing}, the \emph{resizing rules} allow
to lower the universe level of a type under special conditions. The way he
presented them would make type checking undecidable.
We studied the possibility of a definition better suited to implementation
as well as a justification that the rules we propose preserve the consistency
of the system.

\subsection*{Your contribution}

% What is your solution to the question described in the last paragraph ?
% Be careful, do \emph{not} give technical details, only rough ideas !
% Pay a special attention to the description  of the \emph{scientific} approach.
We propose a way to implement resizing rules in Coq (which will be possible in
the next release) with precise typing rules.
We then show that -- up to some axioms that are consistent in a univalent
setting -- all resizing rules that we proposed %(and that correspond to the ones
% of Voevodsky)
can be reduced to only one.
We finally show the consistency of this one rule by generalizing a result by
Nicolas Oury~\cite{oury2005extensionality} stating that we can translate
extensional type theory into intensional type theory in a univalent setting
(up to now it relied on the uniqueness of identity proofs that is incompatible
with univalence).
This last step is, in itself, an interesting result.

\subsection*{Arguments supporting its validity}

% What is the evidence that your solution is a good solution ?
% Experiments ? Proofs ?
Our work consists of a proof and an implementation.
However, our proof relies on some axioms that we deem consistent in a univalent
setting but this would require more work to justify their use more explicitely.

% Comment the robustness of your solution:
% how does it rely/depend on the working assumptions ?

\subsection*{Summary and future work}

% What is next ? In which respect is your approach general ?
% What did your contribution bring to the area ?
% What should be done now ?
% What is the good \emph{next} question ?
Our approach goes through a very gereral interpretation of extensional type
theory into intensional type theory which is an interesting result unavailable
in homotopy type theory. Besides we allow the use of resizing rules in actual
proofs in Coq.
Still, as we pointed out, we rely on an axiom and it would be interesting to
see if it holds in the simplicial model~\cite{kapulkin2012simplicial} which is
the mainstream model of univalent homotopy type theory.

\subsection*{Notes}

Given that this report might serve as a basis for articles we decided to write
it in English.

\newpage
\pagestyle{plain} %

\section{Homotopy Type Theory}

We will start by briefly presenting type theory and then go to its homotopic
counterpart.

\subsection{Proof Theory and Proof Assistants}

The Curry-Howard isomorphism~\cite{howard1995formulae} sets the basis for seeing
$\lambda$-terms as proofs and types as propositions. Since then, many systems
such as Martin-L\" of Type Theory~\cite{manin1975intuitionistic} (the theory
behind Agda) or the Calculus of Inductive Constructions (CIC -- the theory
behind Coq) extended it to dependent
types that allow types to depend on terms.
% This way, the dependent product $\Pi x:A.B$ (where $B$ can mention $x$)
% represents the proposition $\forall x:A, B$.
We shall assume the reader is familiar with basic concepts associated to CIC
such as the inductive types as CIC will serve as our implicit context.

\subsection{Proofs and Equality}

Even though in Coq one notion of equality is built-in, the conversion which
identifies terms up to $\beta$-reductions, it is often interesting to talk
about equality inside of proof terms.
We thus use the so-called identity types $\Id\ A\ u\ v$, meaning the type of
proofs that $u$ and $v$ of type $A$ are equal. It is often written
$u =_A v$ or even $u = v$ when $A$ is understood.
$\Id\ A\ x\ x$ has one inhabitant: $\refl_x$,
basically this means that we can only prove equality of objects that are already
convertible without relying on hypotheses of course. This is the smallest
reflexive relation.

\begin{wrapfigure}{r}{0.25\textwidth}
    \centering
    \includegraphics[scale=.4]{s1.eps}
\end{wrapfigure}
Homotopy type theory~\cite{HoTTbook} comes with concepts that tend to inhabit
equality through other means than reflexivity. For instance, it introduces the
notion of \emph{higher inductive types}~\cite{lumsdaine2013higher} that are not
only described by constructors but also by equalities.
The most standard example is probably the circle $\S1$ that has one constructor
$\base : \S1$ and one non-trivial equality $\sloop : \base = \base$
(in the figure on the right we implicitely see an equality as a directed arrow).
This can go against the intuition but this type doesn't have only one element,
\ie it is not provable that $\forall x,y : \S1.\ x = y$. It is however
reassuring that the circle doesn't consist of only one point.
All equalities in $\sloop = \sloop$ aren't provably equal either.
However, for a type such as $\bool$ whose elements are not all
identifiable (we can even prove $\true \neq \false$), we can prove that all
proofs of $b_1 =_{\bool} b_2$ are equal, but this does not come easily.
This gives rise to a classification of types depending on the properties
of their (higher) equalities.

\begin{definition}[$n-\Type$s]
  \leavevmode
  \begin{itemize}
    \item We say a type $T$ is \emph{contractible} (or a $(-2)-\Type$) when
          there is $t : T$ such that $\forall x : T. x = t$.
    \item We say that $T$ is an $(n+1)-\Type$ when for all $x, y : T$, the type
          $x =_T y$ is an $n-\Type$.
  \end{itemize}
\end{definition}
%
\noindent
In particular, we shall say that a $(-1)-\Type$ is a \emph{(mere) proposition}
following the intuition that such a type is either \emph{true} ($\top$ -- the
unit type) or \emph{false} ($\bot$ -- the empty type).
We also say that a $0-\Type$ is a \emph{set} as it verifies uniqueness of
identity proofs as sets of set theory.

For instance, $\bool$ is a set as all proofs of $b_1 = b_2$ are equal, but it
is not a mere proposition because $\true = \false$ is not inhabited and thus
not contractible.

\paradot{Transport}
We represented the circle by drawing $\sloop$ as a path from $\base$ to
$\base$, this way of representing the equality can be explicited by the notion
of transport.
Basically, given $p : A =_{\Type} B$, it is possible to construct a function
$p_* : A \to B$ using the elimination principle of equality.

\paradot{Operations}
The elimination principle for equality can be annoying to use in general so we
rather prove basic lemmata that make reasoning about equality easier.
One that is useful for instance is the congruence of equality under application:
\[ \ap : \forall (f : A \to B).\ x =_A y \to f\ x =_B f\ y. \]
\noindent
It has a precise definition that we won't state here, but it basically
follows directly from the elimination principle of the equality.

Similarly for any $p : x = y$ and $q : y = z$, we can define
$p\inv : y = x$ and $p \cons q : x = z$ translating symmetry and transitivity.

\subsection{Univalence}

As we already mentioned, univalence is a principle that basically allows to
identify objects that are equivalent. To really give meaning to those words we
need to define what we mean by equivalence.

\begin{definition}[Equivalence]
  Given $A$, $B$ and $f : A \to B$, we say that $f$ is an equivalence
  if there exist the following terms:
  \begin{itemize}
    \item $g : B \to A$,
    \item $\eta : \forall a:A.\ g\ (f\ a) = a$,
    \item $\epsilon : \forall b:B.\ f\ (g\ b) = b$,
    \item $\alpha : \forall a:A.\ \ap\ f\ (\eta\ a) = \epsilon\ (f\ a)$.
  \end{itemize}
  We write $A \approx B$ for the type of equivalences between $A$ and $B$.
\end{definition}

\noindent
An interesting thing to remark is that if $A$ and $B$ are sets, then an
equivalence is exactly a bijection between types (which incidently is the notion
of isomorphism for sets).

Using transports it is trivial to construct an equivalence between two equal
types $A = B$ which gives us an arrow $f : (A = B) \to (A \approx B)$.
The principle of univalence states that this arrow itself is an equivalence.

\begin{definition}[Univalence]
  The univalence axiom states that
  the trivial arrow $(A = B) \to (A \approx B)$ is itself an equivalence.
\end{definition}

\noindent
This means in particular that two equivalent types are equal (which is usually
how univalence is presented to people that aren't familiar with homotopy type
theory) but it actually says more. The way to construct the equality is related
to the equivalence.
For instance, if you take a look at $\bool$, there are two ways to prove
$\bool = \bool$, the usual straightforward way which corresponds to the identity
and the twisted way coming from univalence that exchanges $\true$ and $\false$.

\section{Resizing Rules}

We will now present the resizing rules and try to justify their need.

\subsection{Motivations}

Consistency in Coq relies on a hierarchy of universes $\Type_i$ with
$\Type_i : \Type_{i+1}$. Even though this is usually hidden to the user
(who only sees $\Type$), sometimes the user gets presented with a
``universe inconsistency''. This happens for instance when a function was
defined over $\Type_3$ but we provided a type in $\Type_4$.
This is of course the expected behavior, however in some cases the universe
level of an object grew artifically.

Take the notion of subsets: if we want to take a subset of $A$ satisfying
a given predicate $P$, we write $B := \{ x : A \mid P\ x \}$ in Coq.
The problem is that $P$ could live in high universes, making the universe level
of $B$ grow as well, meaning it could be bigger than the one of $A$ although
it was originally intended as a subset of $A$.
The consequences are that some properties of $A$ might not be inherited by
$B$ because of universe constraints.
One of the resizing rules proposed by Vladimir Voevodsky states that any
mere proposition can be taken in the smallest universe ($\Type_0$).
In our case it would lower the universe of $P\ x$ and $B$ would fit in the same
universe as $A$.

This is meant as a motivation to research resizing rules but this does not mean
that they are necessary or even strengthen our system.
We will consider them as a tool that makes your life better when dealing with
universe problems in Coq.

\subsection{Original Statement}

In a talk he gave~\cite{vv:resizing}, Vladimir Voevodsky proposed several
resizing rules that would be helpful in UniMath~\cite{UniMath}, a formalisation
of univalent foundations of mathematics in Coq. At the time of the writing, they
are using the option ``type-in-type'' (which allows $\Type : \Type$, collapsing
the universe hierarchy) to avoid those universe problems.

The first one is the one we already mentioned that says that mere propositions
are small. It is consistent with the remark we made about mere propositions
saying that they are intuitively $\top$ or $\bot$ which incidentally live in
$\Type_0$. We write $\ishProp\ T$ the type of proofs that $T$ is a mere
proposition.

\begin{mathc}
  \ru{\Gamma \der h : \ishProp\ T
    }{\Gamma \der T : \Type_0}
\end{mathc}

$\hProp$, the type of mere propositions (a $\Sigma$-type containing a type $T$
and a proof $\ishProp\ T$), can be seen as $\bool$ if we extend our intuition
to saying that it only contains $\top$ and $\bot$. We also would like to put in
the smallest universe.

\begin{mathc}
  \ru{}{\Gamma \der \hProp : \Type_0}
\end{mathc}

If we consider two types to be equal, it only seems natural that they can live
in the same universe. As of now, if $A : \Type_i$ and $B : \Type_j$, then we
can consider $A =_{\Type_{\max(i,j)}} B$ in the biggest universe of the two
when we would like to see both of them in the smallest.
This gives the following rule:

\begin{mathc}
  \ru{A : \Type_i \qquad
      e : A = B
    }{B : \Type_i}
\end{mathc}

Similarly (especially if we think in univalent terms), we can state a rule for
equivalence that generalize the previous one:

\begin{mathc}
  \ru{A : \Type_i \qquad
      h : A \approx B
    }{B : \Type_i}
\end{mathc}

As one can see, these rules seem to break decidability of type checking, hence
the need for a more explicit statement of those rules.

\meta{Mention the surjection rule somehow?}

\subsection{Implementation Proposal}

In order to preserve decidability of type checking, we explicitly tag the
resized version of a type by $\RR$. For instance, the rule for equivalence
becomes:

\begin{mathc}
  \ru{A : \Type_i \qquad
      B : \Type_j \qquad
      h : A \approx B
    }{\RR\ A\ h : \Type_j}
\end{mathc}

\noindent
However, we need to relate $\RR\ A$ (we will ignore the $h$ as it is understood
in most cases) and $A$ in some way. Mike Shulman (\meta{cite?}) for instance
proposed to say that $\RR\ A$ and $A$ are equivalent, but in this precise case,
this is not really interesting as we could have used $B$ from the start.
Instead we use a \emph{strict equivalence}:

\begin{mathc}
  \ru{\Gamma \der t : A
    }{\Gamma \der \inj\ t : \RR\ A}
  \qquad
  \ru{\Gamma \der t : \RR\ A
    }{\Gamma \der \proj\ t : A}
\end{mathc}
%
\noindent
such that $\proj\ (\inj\ t) \equiv t$ and $\inj\ (\proj\ t) \equiv t$ are
conversions that hold in the system (the equalities of the equivalence are not
only provable but definitional).
This corresponds to records with primitive projections in Coq, hence the
decidability.
%
This can be achived in Coq thanks to Pierre-Marie Pédrot~\cite{pperdot:pr} by
deactivating the universe checking locally to create a record that holds a
value of type $A$.

All the rules can be treated similarly.


\section{One Rule to Resize Them All}

As a means to justify the consistency of those rules, we wondered if it was not
possible to reduce all rules to one. We show here several candidates.

\subsection{Embedding}
The first candidate we had was the embedding resizing rule.
We say that $f : A \to B$  is an \emph{embedding} when $\ap\ f$ is an
equivalence (we write $A \embd B$ for the type of embeddings).
To put it simply, we have $(x =_A y) \approx (f\ x =_B f\ y)$.
For sets, it corresponds to injective maps:
$f\ x = f\ y \to x = y$.
In such a case it feels natural to consider $A$ to be smaller than $B$:

\begin{mathc}
  \ru{\Gamma \der A : \Type_i \qquad
      \Gamma \der B : \Type_j \qquad
      \Gamma \der h : A \embd B
    }{\Gamma \der \RR\ A : \Type_j}
\end{mathc}

\noindent
This was a good candidate in the sense that any mere proposition can be embedded
in $\top$ and that $A \approx B$ implies $A \embd B$.
However, this does not allow us to resize $\hProp$ itself and we were not able
to find a good justification for it.

\subsection{Equivalence}
If we are ready to rely on some axioms we can reduce all the resizing rules we
mentioned (even the embedding one) to the equivalence resizing rule.
For instance, the equality can trivially be reduced to equivalence.
The other need more work and we shall detail them below.

\paradot{Mere Propositions}
In HoTT with univalence, the excluded-middle $\forall T.\ T + \neg T$ is
inconsistent. However its restriction to mere propositions can be safely
assumed.
\[\emd : \forall (T:\hProp).\ T + \neg T.\]
In a way, it makes sense as we really want to decide whether a proposition is
true or not rather than whether a type is inhabited or not.

Once we have that, for any mere proposition $T$, we can create the type $T'$
that is $\top$ or $\bot$ depending on the result of $\emd\ T$.
That way $T' : \Type_0$ and $T \approx T'$.
We can conclude it is safe to assume the resizing of mere propositions as long
as it is safe to assume the excluded-middle for them and the resizing of
equivalence.

Likewise, we can show that $\hProp \approx \bool$ using $\emd$ in the same
fashion, and, since $\bool : \Type_0$, the resizing rule of $\hProp$ is also
reducible to equivalence.
\meta{Doesn't it use univalence as well?}

\paradot{Embeddings}
\meta{Say it is equivalent to the image of $f$, how much into details should we
go? As for the rest, we should probably have it proven in a Coq file and leave
it to the interested reader.}

\subsection{Equality}
It is tempting to say that equivalence is the one rule that generalizes all the
others, however for the purpose of the proof, it is worth noting that under
univalence we can reduce it to the equality rule.
Once we have $e : A = B$ it feels like we could simply choose $\RR\ A$ to be
$B$ and use $e$ and $e\inv$ respectively for $\inj$ and $\proj$,
however, unless $e = \refl$, $e\inv_*\ (e_*\ t) \equiv t$ does not hold
definitionally.

Nevertheless, if we could turn $A = B$ into $A \equiv B$, we would have won.

\section{Extensional to Intensional}

\subsection{State of the Art}

In order to justify the resizing rule for equality, we would like to transform
a propositional equality into a conversion rule:

\begin{mathc}
  \ru{\Gamma \der p : u = v
    }{\Gamma \der u \equiv v}
\end{mathc}
%
The above rule is a bridge between intensional and extensional type theory.
Extensional type theory is more powerful as the equality is able to relate a lot
more terms. This comes at the price of decidability for the type checking but it
is still used in proof assistants like Nuprl~\cite{constableimplementing} or
Andromeda~\cite{andromeda}.

Nicolas Oury~\cite{oury2005extensionality} proposed a proof of the consistency
of such an extension of Coq by creating a program translation that associates a
derivation in the extensional calculus to a derivation in the intensional one
such that a proof of $\bot$ is translated to a proof of $\bot$.
The problem is that this translation relies on the uniqueness of identity
proofs (UIP) that is not compatible with univalence.

It is worth noting that Van Doorn \etal \cite{van2013explicit} proposed a
similar proof by showing the equivalence between a PTS (Pure Type System) with
explicit conversion and one without. Indeed, the translation from the
extensional type theory maps conversions to transports that can be seen as
explicit conversions.

\subsection{Translation compatible with Univalence}

As we said, the work of Nicolas Oury relies on UIP -- which cannot be assumed in
HoTT -- but in name only. Indeed, if we only assume it for equalities over
type, namely:
\[ \forall (p : \Type_i = \Type_i).\ p = \refl, \]
then we can adapt the proof so that it still holds.
There is of course the question of whether it is safe to assume it and, while
we don't have a definite proof, it appears that for parametricity reasons,
it is not possible to build an equivalence between $\Type_i$ and itself that
is not the identity.

Let us now detail the adapted proof.

\subsubsection{(Extensional) Calculus of Constructions}

Our goal is to translate judgements in the Extensional Calculus of
Constructions (herrafter called \CCe) into the regular Calculus of Constructions
(CC). Contexts will be either the empty context $\cdot$ or of the form
$\Gamma, x:T$ and $\der \Gamma$ shall mean that the context $\Gamma$ is
well-formed.

We will write $s$ for sort variables, sorts being of the form $\Type_i$ for
some $i$. CC is also equipped with a relation between sorts for the function
spaces formation: $(\Type_i, \Type_j, \Type_{\max(i,j)})$.

The typing rules of CC are given in figure~\ref{fig:cc-typ} while its
convertibility rules (judgements of the form $\Gamma \der t \equiv t'$) are
given in figure~\ref{fig:cc-conv}.

\begin{figure}[h]
  \hrule \vspace*{2ex}%

  \begin{mathc}
    \nmru{ECon}{}{\der \cdot}
    \qquad
    \nmru{I-Con%
        }{\Gamma \der A : s
        }{\der \Gamma, x:A}
    \qquad
    \nmrux{Var%
         }{\der \Gamma
         }{\Gamma \der x : A
         }{(x : A) \in \Gamma}
  \end{mathc}

  \begin{mathc}
    \nmru{Type}{}{\der \Type_i : \Type_{i+1}}
    \qquad
    \nmru{Univ%
        }{\Gamma \der A : \Type_i
        }{\Gamma \der A : \Type_{i+1}}
  \end{mathc}

  \begin{mathc}
    \nmrux{Prod%
         }{\Gamma \der A : s_1 \qquad
           \Gamma, x:A \der B : s_2
         }{\Gamma \der \forall x:A.B : s_3
         }{(s_1,s_2,s_3)}
  \end{mathc}

  \begin{mathc}
    \nmru{App%
        }{\Gamma \der t : \forall x:A.B \qquad
          \Gamma \der u : A
        }{\Gamma \der t\ u : B[x := u]}
    \qquad
    \nmru{Lam%
        }{\Gamma, x:A \der t : B
        }{\Gamma \der \lambda x:A.t : \forall x:A.B}
  \end{mathc}

  \begin{mathc}
    \nmru{Conv%
        }{\Gamma \der A \equiv B \qquad
          \Gamma \der t : A \qquad
          \Gamma \der B : s
        }{\Gamma \der t : B}
  \end{mathc}

  % \vspace*{2ex} \hrule%
  \hrule%

  \caption{Typing Rules of CC}
  \label{fig:cc-typ}
\end{figure}

\begin{figure}[h]
  \hrule \vspace*{2ex}%

  \begin{mathc}
    \nmru{$\beta$%
        }{\Gamma \der (\lambda x:A. t)\ u : T
        }{\Gamma \der (\lambda x:A. t)\ u \equiv t[x := u]}
    \qquad
    \nmru{CApp%
        }{\Gamma \der t_1 \equiv t_2 \qquad
          \Gamma \der u_1 \equiv u2
        }{\Gamma \der t_1\ u_1 \equiv t_2\ u_2}
  \end{mathc}

  \begin{mathc}
    \nmru{CProd%
        }{\Gamma \der A_1 \equiv A_2 \qquad
          \Gamma, x:A_1 \der B_1 \equiv B_2
        }{\Gamma \der \forall x:A_1.B_1 \equiv \forall x:A_2.B_2}
  \end{mathc}

  \begin{mathc}
    \nmru{CLam%
        }{\Gamma \der A_1 \equiv A_2 \qquad
          \Gamma, x:A_1 \der t_1 \equiv t_2
        }{\Gamma \der \lambda x:A_1.t_1 \equiv \lambda x:A_2.t_2}
  \end{mathc}

  \hrule%

  \caption{Convertibility Rules of CC}
  \label{fig:cc-conv}
\end{figure}

In order to obtain \CCe we only add the extensionality rule below.
All judgements in \CCe will be written with $\dere$ whereas CC will use $\der$.
\begin{mathc}
  \nmru{Ext%
      }{\Gamma \dere p : u_1 = u_2
      }{\Gamma \dere u_1 \equiv u_2}
\end{mathc}

Please remark that, as in the work of Nicolas Oury, we will not speak about the
typing rules of the propositional equality as it would hinder readability.
Besides, our translation will actually go in the Calculus of Inductive
Constructions, the theory of Coq at full power with inductive types,
pattern-matching and fixpoints. It will also be extended with a few
parametricity axioms that we will discuss later.

\subsubsection{Principle of the Translation}

The main idea behind the translation is to turn every conversion
$\Gamma \der t_1 \equiv t_2$ into a proof of equality
$\Gamma \der p : t_1 = t_2$ and then to translate the conversion
rule to a transport.
\begin{mathc}
  \ru{\Gamma \der t : A \qquad
      \Gamma \der p : A = B \qquad
      \Gamma \der B : s
    }{\Gamma \der p_*\ t : B}
\end{mathc}
This stresses out the fact that we cannot embed the extensional
conversion into the intensional one as we need to keep more information
about why the two types are equal. Thus, we switch to explicit
conversions in the target system.

This is however not so simple as the terms involved are also translated,
most likely labeled by transports. Moreover, a given term can have
several translations depending on the chosen typing derivation.
This problem can arise when a rule like (\rulename{CApp}) mentions twice the
same term in two different derivations.
In order for that not to be a problem we have to be able to relate different
translations of a given term. We thus have to chose some equality judgement
to do so.

\subsubsection{Heterogenous Equality}

We already stated that the conversion is not the right choice to compare two
translations of a term.
Besides, two translations can be different, but also of different types.
This means that the propositonal equality is also not best suited for our task
as it requires both terms it compares to inhabit the same type.

In his work, Nicolas Oury relied on an heterogeneous propositional equality
often called John Major equality~\cite{mcbride2000dependently}:
$\JMeq\ A\ a\ B\ b$ for any $a : A$ and $b: B$
with $\JMrefl_a : \JMeq\ A\ a\ A\ a$.
However he relies on UIP to derive the following property that links it with
the usual propositional equality:
\[\JMeq\ A\ u_1\ A\ u_2 \to u_1 =_A u_2.\]
This property itself is not compatible with univalence so we don't want to rely
on it. However, we noticed that it is only necessary to have it when $A$ is a
sort (meaning some $\Type_i$).

In order to emulate heterogeneous equality with the tools of HoTT, we will
instead rely on equality between pointed types.
To compare $a : A$ and $b : B$ we will compare (with the propositional equality)
the pairs $(A,a)$ and $(B,b)$ of type $\Sigma (T : Type).T$.
Proving $(A,a) = (B,b)$ comes down to first finding $p : A = B$ and then
proving $p_*\ a =_B b$.
Let us now remind the axiom we mentioned earlier:
\[ \axt : \forall (p : \Type = \Type).\ p = \refl. \]
It becomes useful now as it allows us to recover an homogeneous equality from
an heterogeneous equality on $\Type$:
\[ (\Type, A) = (\Type, B) \to A = B. \]
This will prove sufficient for us as we only want to recover equalities to
make transports (that only come for types).

\subsubsection{Term Equivalence}

We want to equate all translations of the same term, however it is not possible
to prove it by induction during the translation directly. In homotopy terms
we need a center of contraction, \ie a fixed object that will serve as the
intermediary between all translations of the same term.
The following \emph{untyped} relation serves this purpose.

\begin{definition}
  We define the relation $\sim$ on CIC terms by induction:
  \begin{mathc}
    {\color{gray}
      \rux{}{x \sim x}{x \text{ variable}}
    }
    \qquad
    \ru{t_1 \sim t_2
      }{p_*\ t_1 \sim t_2}
    \qquad
    \ru{t_1 \sim t_2
      }{t_1 \sim p_*\ t_2}
    \qquad
    {\color{gray}
      \ru{t_1 \sim t_2 \qquad
          u_1 \sim u_2
        }{t_1\ u_1 \sim t_2\ u_2}
    }
  \end{mathc}
  \begin{mathc}
    \color{gray}
    \ru{A_1 \sim A_2 \qquad
        t_1 \sim t_2
      }{\lambda x:A_1.t_1 \sim \lambda x:A_2.t_2}
    \qquad
    \ru{A_1 \sim A_2 \qquad
        B_1 \sim B_2
      }{\forall x:A_1.B_1 \sim \forall x:A_2.B_2}
  \end{mathc}
\end{definition}

In black are the most interesting rules while others are simply congruences.
The main idea is that $t_1 \sim t_2$ means that $t_1$ and $t_2$ are the same
terms up to some transports labelling given subterms.
These rules illustrates the need of heterogeneous equality.
We can extend this relation canonically to contexts (pointwise).

Our goal here is to subsume (heterogeneous) equality with this relation.
For that we will discuss some rules that are admissible in CIC with two extra
axioms. They are pretty similar than the one proposed by Nicolas Oury, allowing
to adapt his proof with almost no change.

The first rule we already mentioned allows us to turn an heterogeneous equality
over types into a transport.
\begin{mathc}
  \ru{\Gamma \der \_ : (\Type, A) = (\Type, B)}{\Gamma \der \_ : A = B}
\end{mathc}
Then, we want to relate a term and its transported version.
\begin{mathc}
  \nmru{HSubst%
      }{\Gamma \der p : A = B \qquad
        \Gamma \der t : A
      }{\Gamma \der \_ : (A,t) = (B,p_*\ t)}
\end{mathc}
This actually holds simply by $(p,\refl)$.
Then, we have the different congruences.
We will write $\Gamma \der t = t'$ for $\Gamma \der \_ : t = t'$.
\begin{mathc}
  \nmdru{HProd%
       }{\Gamma \der (s,A_1) = (s,A_2)
       }{\Gamma, x:A_1, y:A_2, p : (A_1,x) = (A_2,y) \der (s,B_1) = (s,B_2)
       }{\Gamma \der (s,\forall x:A_1.B_1) = (s,\forall y:A_2.B_2)}
\end{mathc}
\begin{mathc}
  \nmdru{HLam%
       }{\Gamma \der (s,A_1) = (s,A_2)
       }{\Gamma, x:A_1, y:A_2, p : (A_1,x) = (A_2,y) \der (B_1, t_1) = (B_2,t_2)
       }{\Gamma \der (\forall x:A_1.B_1, \lambda x:A_1.t_1) =
         (\forall y:A_2.B_2, \lambda y:A_2.t_2)}
\end{mathc}
These last two rely on function extensionality which is admissible under
univalence (it can be seen as a weaker version).
\begin{mathc}
  \nmru{HApp%
      }{\Gamma \der (\forall x:A_1.B_1, t_1) = (\forall y:A_2.B_2, t_2) \qquad
        \Gamma \der (A_1,u_1) = (A_2,u_2)
      }{\Gamma \der (B_1[x:=u_1], t_1\ u_1) = (B_2[y:=u_2], t_2\ u_2)}
\end{mathc}
This last one unfortunately isn't provable in Coq without yet an extra axiom
of parametricity. We would actually need such an axiom for every negative
type such as the coinductive types. The axiom states that to prove
$\forall x:A_1.B_1 = \forall x:A_2.B_2$, you have to prove $A_1 = A_2$
and ``$B_1 = B_2$''.

We can finally prove that two equivalent terms are equal.

\begin{lemma}
  \label{lem:simeq}
  If $t_1 \sim t_2$ and $\Gamma \der t_1 : T_1$ and $\Gamma \der t_2 : T_2$
  then there exists $p$ such that $\Gamma \der p : (T_1,t_1) = (T_2,t_2)$.
\end{lemma}

\begin{proof}
  We first extend the relation $\sim$ with a set of pairs of variables $E$
  such that if $(x,y) \in E$ then $x \sim_E y$ and $t_1 \sim t_2$ implies
  $t_1 \sim_E t_2$.
  We then prove by induction on the formation of $\sim_E$ that for all $E$,
  $\Gamma$ if for all $(x,y) \in E$ we have $\Gamma \der (\_,x) = (\_,y)$ and if
  $t_1 \sim_E t_2$ and $\Gamma \der t_1 : T_1$ and $\Gamma \der t_2 : T_2$
  then $\Gamma \der (T_1,t_1) = (T_2,t_2)$.
  \begin{itemize}
    \item For $(x,y) \in E$, the result is in the hypothesis.
    \item For $x \sim_E x$, the result can be obtained by reflexivity.
    \item For $t_1 \sim_E p_*\ t_2$, by induction hypothesis,
          $\Gamma \der (T_1,t_1) = (T_2,t_2)$ and we conclude by
          (\rulename{HSubst}).
    \item For $t_1\ u_1 \sim_E t_2\ u_2$, we conclude by using
          (\rulename{HApp}) using the induction hypotheses.
    \item For $\forall x:A_1.B_1 \sim_E \forall y:A_2.B_2$ (we use $y$ instead
          of $x$ by $\alpha$-conversion), we consider
          $E' := E \bigcup \{ (x,y) \}$ and conclude by induction hypothesis
          that $\Gamma \der (s,A_1) = (s,A_2)$ and
          $\Gamma, x:A_1, y:A_2, p : (A_1,x) = (A_2,y) \der
          (s',B_1) = (s',B_2)$.
          We conclude by using (\rulename{HProd}).
    \item The $\lambda$-abstraction case is similar and we conclude by
          (\rulename{HLam}).
  \end{itemize}
  The original statement is proven using $E = \emptyset$.
\end{proof}
Remark that implicitely, we used some inversion lemmata to type the subterms
of the involved terms in order to conclude, they do hold but we won't detail it
here.

\begin{lemma}[Subsitution]
  \label{lem:subst}
  If $t_1 \sim t_2$ and $u_1 \sim u_2$ then $t_1[x := u_1] \sim t_2[x := u_2]$.
\end{lemma}

\begin{proof}
  By induction on the derivation of $t_1 \sim t_2$.
\end{proof}

\subsubsection{Proof of the Translation}

We now have the setting to link different translations of a given term.
Let us give a precise meaning to a translation so that it becomes apparent.

\begin{definition}[Translation]
  For any valid judgement $\mathcal{J}$ in \CCe, we define a set of valid
  judgements $\den{\mathcal{J}}$ in CIC as follows:
  \leavevmode
  \begin{itemize}
    \item $\der \cdot \in \den{\dere \cdot}$.
    \item $\der \barG, x:\barT \in \den{\der \Gamma, x:T}$
          when $\der \barG \in \den{\dere \Gamma}$ and
          $\barT \sim T$.
    \item $\barG \der \bart : \barT$ when
          $\der \barG \in \den{\dere \Gamma}$ and
          $\bart \sim t$ and $\barT \sim T$.
  \end{itemize}
\end{definition}

\begin{lemma}
  \label{lem:choice}
  We can always chose types $\barT$ that have the same head constructor
  as $T$.
\end{lemma}

\begin{proof}
  Assume $\barG \der \bart : \barT$, then $\barT \sim T$ and thus,
  by definition of $\sim$, $\barT$ can be written as
  ${p_1}_*\ (...)\ {p_n}_*\ \barT'$ where $\barT' \sim T$ and $\barT'$ has
  the same head constructor as $T$ (when you can no longer apply the rule
  with transport labelling, you have to apply the corresponding congruence
  rule).
  Since $\sim$ ignores all transports, we have $\barT \sim \barT'$.
  Since they are both types, by lemma~\ref{lem:simeq},
  $\Gamma \der p : (\Type,\barT) = (\Type,\barT')$ and using $\axt$ we can
  assume $\Gamma \der p : \barT = \barT'$ instead.
  Finally we have $\barG \der p_*\ \bart : \barT' \in \den{\Gamma \der t : T}$.
\end{proof}

We now prove our translation.

\begin{theorem}[Validity of the Translation]
  \label{thm:valid}
  The following properties hold:
  \leavevmode
  \begin{enumerate}
    \item If $\Gamma \dere t : T$ then, there exists
    $\der \barG \in \den{\dere \Gamma}$
    and for any such $\barG$ there exists $\bart$ and $\barT$ such
    that $\barG \der \bart : \barT \in \den{\Gamma \dere t : T}$.
    \item If $\dere \Gamma$ then there exists $\barG \in \den{\dere \Gamma}$.
    \item If $\Gamma \dere t_1 \equiv t_2$ then there exists
    $\barG \der \barp : (\barT_1,\bart_1) = (\barT_2,\bart_2) \in
    \den{\Gamma \dere p : (T_1,t_1) = (T_2,t_2)}$.
  \end{enumerate}
\end{theorem}

\begin{proof}
  We proceed by induction on the derivation in \CCe.
  \begin{caselist}
    \nextcase $\nmru{ECon}{}{\dere \cdot}$.
    We have $\der \cdot \in \den{\dere \cdot}$.

    \nextcase
    \(
    \nmru{I-Con%
        }{\Gamma \dere A : s
        }{\dere \Gamma, x:A}
    \).
    By induction hypothesis there exists
    $\barG \der \barA : s \in \den{\Gamma \dere A : s}$ (implicitely using
    lemma~\ref{lem:choice}). Thus
    $\der \barG, x:\barA \in \den{\dere \Gamma, x:A}$.

    \nextcase
    \(
      \nmrux{Var%
           }{\dere \Gamma
           }{\Gamma \dere x : A
           }{(x : A) \in \Gamma}
    \).
    By induction hypothesis, there exists $\der \barG \in \den{\dere \Gamma}$.
    For any such $\barG$ we have $(x : \barA) \in \barG$ for some $\barA \sim A$
    by definition of $\den{\dere \Gamma}$ and thus
    $\barG \der x : \barA \in \den{\Gamma \dere x : A}$.

    \nextcase \(\nmru{Type}{}{\dere \Type_i : \Type_{i+1}}\).
    This translates to the same rule in CIC.

    \nextcase \(
      \nmru{Univ%
          }{\Gamma \dere A : \Type_i
          }{\Gamma \dere A : \Type_{i+1}}
    \).
    By induction hypothesis
    $\barG \der \barA : \Type_i \in \den{\Gamma \dere A : \Type_i}$
    and thus
    $\barG \der \barA : \Type_{i+1} \in \den{\Gamma \dere A : \Type_{i+1}}$.

    \nextcase \(
      \nmrux{Prod%
           }{\Gamma \dere A : s_1 \qquad
             \Gamma, x:A \dere B : s_2
           }{\Gamma \dere \forall x:A.B : s_3
           }{(s_1,s_2,s_3)}
    \).
    By induction hypothesis
    $\barG \der \barA : s_1 \in \den{\Gamma \dere A : s_1}$ and
    thus $\der \barG, x:\barA \in \den{\dere \Gamma, x:A}$ so by second
    induction hypothesis
    $\barG, x:\barA \der \barB : s_2 \in \den{\Gamma, x:A \dere B : s_2}$.
    We conclude by saying
    $\barG \der \forall x:\barA.\barB : s_3
    \in \den{\Gamma \dere \forall x:A.B : s_3}$.

    \nextcase \(
      \nmru{App%
          }{\Gamma \dere t : \forall x:A.B \qquad
            \Gamma \dere u : A
          }{\Gamma \dere t\ u : B[x := u]}
    \).
    By induction hypotheses
    $\barG \der \bart : \forall x:\barA.\barB \in
    \den{\Gamma \dere t : \forall x:A.B}$ and
    $\barG \der \baru : \barA' \in \den{\Gamma \dere u : A}$.
    Then we have $\barA \sim A$ and $\barA' \sim A$ so $\barA \sim \barA'$
    and thus, by lemma~\ref{lem:simeq}, we have $\barG \der \barA = \barA'$
    (as they are both types we dropped the first component).
    Up to some transport we can safely assume
    $\barG \der \baru : \barA \in \den{\Gamma \dere u : A}$.
    We can then conclude
    $\barG \der \bart\ \baru : \barB[x := \baru] \in
    \den{\Gamma \dere t\ u : B[x := u]}$ (using lemma~\ref{lem:subst}).

    \nextcase \(
      \nmru{Lam%
          }{\Gamma, x:A \dere t : B
          }{\Gamma \dere \lambda x:A.t : \forall x:A.B}
    \).
    By induction hypothesis
    $\barG, x:\barA \der \bart : \barB \in
    \den{\Gamma, x:A \dere t : B}$ and thus
    $\barG \der \lambda x:\barA.\bart : \forall x:\barA.\barB \in
    \den{\Gamma \dere \lambda x:A.t : \forall x:A.B}$.

    \nextcase \(
      \nmru{Conv%
          }{\Gamma \dere A \equiv B \qquad
            \Gamma \dere t : A \qquad
            \Gamma \dere B : s
          }{\Gamma \dere t : B}
    \).
    By induction hypotheses (silently using lemma~\ref{lem:simeq} and $\axt$)
    $\barG \der \barp : \barA = \barB \in \den{\Gamma \dere p : A = B}$
    and $\barG \der \bart : \barA \in \den{\Gamma \dere t : A}$.
    We can conclude $\barG \der \barp_*\ \bart : \barB \in
    \den{\Gamma \dere t : B}$.

    \nextcase \(
      \nmru{Ext%
          }{\Gamma \dere p : u_1 = u_2
          }{\Gamma \dere u_1 \equiv u_2}
    \).
    By induction hypothesis,
    $\barG \der \barp : \baru_1 = \baru_2 \in \den{\Gamma \dere p : u_1 = u_2}$.
    Thus $\barG \der (\refl,p) : (\_,\baru_1) = (\_,\baru_2) \in
    \den{\Gamma \dere u_1 \equiv u_2}$.
    (Remark: This case illustrates how we could have used our pointed-type
    heterogeneous equality in the \CCe.)

    \nextcase \(
      \nmru{$\beta$%
          }{\Gamma \dere (\lambda x:A. t)\ u : T
          }{\Gamma \dere (\lambda x:A. t)\ u \equiv t[x := u]}
    \).
    By induction hypotheses, lemmata~\ref{lem:simeq} and~\ref{lem:choice} and
    inversion of typing, we have
    $\barG \der \lambda x:\barA.\bart : \forall x:\barA.\barB$ and
    $\barG \der \baru : \bar \barA$.
    By $\beta$-reduction we have the conversion which can be turned into
    an heterogeneous equality with the proof term $(\refl,\refl)$.

    \nextcase \(
      \nmru{CApp%
          }{\Gamma \dere t_1 \equiv t_2 \qquad
            \Gamma \dere u_1 \equiv u2
          }{\Gamma \dere t_1\ u_1 \equiv t_2\ u_2}
    \).
    We conclude by our rule (\rulename{HApp}).

    \nextcase \(
      \nmru{CProd%
          }{\Gamma \dere A_1 \equiv A_2 \qquad
            \Gamma, x:A_1 \dere B_1 \equiv B_2
          }{\Gamma \dere \forall x:A_1.B_1 \equiv \forall x:A_2.B_2}
    \).
    This is equivalent in \CCe\ to
    \[
      \ru{\Gamma \dere A_1 \equiv A_2 \qquad
          \Gamma, x:A_1, y:A_2, p : x = y \dere B_1 \equiv B_2[x := y]
        }{\Gamma \dere \forall x:A_1.B_1 \equiv \forall x:A_2.B_2}.
    \]
    We can then conclude by (\rulename{HProd}).

    \nextcase (\rulename{CLam}) can be treated by (\rulename{HLam}) in a similar
    fashion.
  \end{caselist}
\end{proof}

Now that we have defined a translation, we need to ensure it implies the
consistency of \CCe\ with respect to CIC (plus our axioms).

\begin{corollary}
  \label{cor:choice}
  For any $\barG \der \barT : s \in \den{\Gamma \dere T : s}$ and for all
  $t$ such that $\Gamma \dere t : T$ there exists $\bart$ such that
  $\barG \der \bart : \barT \in \den{\Gamma \dere t : T}$.
  In particular if $\Gamma \der T : s$ then there exists $\bart$ such that
  $\Gamma \der \bart : T \in \den{\Gamma \dere t : T}$.
\end{corollary}

\begin{proof}
  By theorem~\ref{thm:valid}.1 we have the traduction and by
  lemma~\ref{lem:simeq} we can chose $T$ for $\barT$.
\end{proof}

\begin{corollary}[Consistency]
  If $\Gamma \dere t : \forall X:\Type.X$
  then $\Gamma \der \bart : \forall X:\Type.X$ for some $\bart$.
\end{corollary}

\begin{proof}
  Immediately by corollary~\ref{cor:choice}.
\end{proof}

\section*{Conclusion}

We presented resizing rules as well as a way to implement them in proof
assistants such as Coq. Thanks to a pretty general result regarding the
consistency of extensional type theory in a univalent context (up to some
parametricity axioms) we were able to prove the consistency of the few
resizing rules that we presented.

As we already mentioned, it would be interesting to try and prove that these
extra axioms actually hold in the simplicial model in order to ``complete''
our coverage of the resizing rules.

% Bibliography
% \nocite{%
%   coq:manual%
% }

\bibliographystyle{plain}
\bibliography{biblio}

\end{document}
