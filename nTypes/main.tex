\documentclass[a4paper,english]{lipics-utf8x}

\usepackage[T1]{fontenc} %

\usepackage{amsmath, amssymb, amsfonts, stmaryrd}
\usepackage{pifont}
\PrerenderUnicode{é} % For the author names in the heading

% Add some colors
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{hyperref}
\hypersetup{
 linktocpage,
 colorlinks,
 citecolor=BlueViolet,
 filecolor=red,
 linkcolor=Blue,
 urlcolor=BrickRed
}

\usepackage{graphicx}
\usepackage{placeins}

% Meta comment
\newcommand\meta[1]{\noindent\textcolor{blue}{\emph{#1}}}

% Include the macro file
\input{macros}

% Title and so...
\title{$n$-Types can stay in their home universe}
\author[1]{Théo Winterhalter}

\begin{document}

  \maketitle

  \begin{abstract}
    We'll try to define a system with no universe hierarchy but with
    $n$-Types, hopefully showing it's consistent and has a decidable type
    checking.
  \end{abstract}

  \section{Syntax}

  \[
    \begin{array}{l@{~}l@{~}l@{~}r@{~}l@{\quad}l}
      \Var  & \ni & x,y,X,Y \\
      \Exp  & \ni & t,u,T,U & ::= & \Pi x:U.T \mid \Sigma x:U.T \mid
                                    t =_T u \mid \nType{n} \\
                         &&& \mid & x \mid \lambda x:U.t \mid t~u
                               \mid (t;u) \mid t.1 \mid t.2 \mid \refl_t \\
                         &&& \mid & \hsig{T ; t}
                               \mid t \gettype \mid t \getproof \\
      \Ctx  & \ni & \Gamma  & ::= & \cdot \mid \Gamma, x:T \\
    \end{array}
  \]

  \section{Typing Rules}

  We give ourselves basic dependent type theory with $\Pi$-types and
  $\Sigma$-types, as well as the indentity types necessary to define the
  $n$-Types.
  This theory doesn't have the usual universes that one require to ensure
  consistency. The goal is to prove that they are unnecessary as long as you
  remain in the realm of $n$-Types (finite homotopy complexity).

  \begin{center}
  \(
    \ru{}{\der \cdot}
    \qquad
    \ru{\Gamma \der T \type \qquad
        x \notin \Gamma
      }{\der \Gamma, x : T}
    \qquad
    \ru{\der \Gamma \qquad
        (x : T) \in \Gamma
      }{\Gamma \der x : T}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t : \Pi x:A.B \qquad
        \Gamma \der t' : A
      }{\Gamma \der t\ t' : B[t'/x]}
    \qquad
    \ru{\Gamma \der A \type \qquad
        \Gamma, x:A \der B \type
      }{\Gamma \der \Pi x:A.B \type}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der \Pi x:A.B : s \qquad
        \Gamma, x:A \der t : B \qquad
        \Gamma \der \Pi x:A.B
      }{\Gamma \der \lambda x:A.t : \Pi x:A.B}
    \qquad
    \ru{\Gamma \der t : \Sigma x:A.B
      }{\Gamma \der t.1 : A}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t : \Sigma x:A.B
      }{\Gamma \der t.2 : B[t.1/x]}
    \qquad
    \ru{\Gamma \der t : A \qquad
        \Gamma \der t' : B[t/x]
        \Gamma \der \Sigma x:A.B
      }{\Gamma \der (t ; t') : \Sigma x:A.B}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der A \type \qquad
        \Gamma, x:A \der B \type
      }{\Gamma \der \Sigma x:A.B \type}
    \qquad
    \ru{\Gamma \der T \type \qquad
        \Gamma \der t,t' : T
      }{\Gamma \der t =_T t' \type}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t : T
      }{\Gamma \der \refl_t : t =_T t}
    \qquad
    \ru{\Gamma \der t : A \qquad
        \Gamma \der B \type \qquad
        \Gamma \der A = B
      }{\Gamma \der t : B}
  \)
  \end{center}

  \meta{TODO: Add an elimination rule for equality.}

  \noindent %
  We then add the rules regarding the $n$-Types, giving us base
  types.
  Basically we are defining types that couldn't be defined without
  quantification on a universe. Our purpose is then to prove
  that all of these $n$-Types can live in the smalleest universe:
  indeed, $\Gamma \der T \type$ can be seen as
  $\Gamma \der T : \Type_0$ in a PTS with smallest universe
  $\Type_0$.

  For this we define $\isnType{n}{T}$ as a shortcut for the following:

  \[
  \begin{array}{l@{~}l}
    \isnType{(-2)}{T}  & := \Sigma x:T. \Pi y:T. x =_T y \\
    \isnType{(n+1)}{T} & := \Pi x:T. \Pi y:T. \isnType{n}{x =_T y}
  \end{array}
  \]

  We also add $\nType{n}$ as a base type for quantification
  purposes. This is basically a $\Sigma$-type except that it is
  defined on the whole universe.

  \begin{center}
  \(
    \ru{}{\Gamma \der \nType{n} \type}
    \qquad
    \ru{\Gamma \der T \type \qquad
        \Gamma \der h : \isnType{n}{T}
      }{\Gamma \der \hsig{T ; h} : \nType{n}}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t : \nType{n}
      }{\Gamma \der t \gettype \type}
    \qquad
    \ru{\Gamma \der t : \nType{n}
      }{\Gamma \der t \getproof : \isnType{n}{t \gettype}}
  \)
  \end{center}

  As one can guess, both $\_ \gettype$ and $\_ \getproof$ are respectively first
  and second projections.

  \meta{Shouldn't homotopy level be a part of the syntax? We need to define them
  somewhere, and the user might want to do a case analysis on them.}

  \section{Equality Rules}

  \paradot{Computation ($\beta$) and extensionality ($\eta$)}

  \begin{center}
  \(
    \ru{\Gamma, x:U \der t:V \qquad
        \Gamma \der u : U
      }{\Gamma \der (\lambda x:U.t)~u = t[u/x] : V[u/x]}
    \qquad
    \ru{\Gamma \der t : \Pi x:U.V
      }{\Gamma \der t = \lambda x:U.t~x : \Pi x:U.V}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t : U \qquad
        \Gamma \der t' : V[t/x]
      }{\Gamma \der (t;t').1 = t : U}
    \qquad
    \ru{\Gamma \der t : U \qquad
        \Gamma \der t' : V[t/x]
      }{\Gamma \der (t;t').2 = t' : V[t/x]}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der T \type \qquad
        \Gamma \der h : \isnType{n}{T}
      }{\Gamma \der \hsig{T;h} \gettype = T}
    \qquad
    \ru{\Gamma \der T \type \qquad
        \Gamma \der h : \isnType{n}{T}
      }{\Gamma \der \hsig{T;h} \getproof = h : \isnType{n}{T}}
  \)
  \end{center}

  \paradot{Equivalence Rules}

  \begin{center}
  \(
    \ru{\Gamma \der t : T
      }{\Gamma \der t = t : T}
    \qquad
    \ru{\Gamma \der t' = t : T
      }{\Gamma \der t = t' : T}
    \qquad
    \ru{\Gamma \der t_1 = t_2 : T \qquad
        \Gamma \der t_2 = t_3 : T
      }{\Gamma \der t_1 = t_3 : T}
  \)
  \end{center}

  \paradot{Compatibility Rules}

  \begin{center}
  \(
    \ru{\Gamma \der U = U' \qquad
        \Gamma, x:U \der V = V'
      }{\Gamma \der \Pi x:U.V = \Pi x:U'.V'}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der U = U' \qquad
        \Gamma, x:U \der V \qquad
        \Gamma, x:U \der t = t' : V
      }{\Gamma \der \lambda x:U.t = \lambda x:U'.t' : \Pi x:U.V}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t = t' : \Pi x:U.V \qquad
        \Gamma \der u = u' : U
      }{\Gamma \der t~u = t'~u' : V[u/x]}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der U = U' \qquad
        \Gamma, x:U \der V = V'
      }{\Gamma \der \Sigma x:U.V = \Sigma x:U'.V'}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t_1 = t'_1 : U \qquad
        \Gamma, x:U \der V \qquad
        \Gamma \der t_2 = t'_2 : V[t_1/x]
      }{\Gamma \der (t_1;t_2) = (t'_1;t'_2) : \Sigma x:U.V}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t = t' : \Sigma x:U.V
      }{\Gamma \der t.1 = t'.1 : U}
    \qquad
    \ru{\Gamma \der t = t' : \Sigma x:U.V
      }{\Gamma \der t.2 = t'.2 : V[t.1/x]}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der T = T' \qquad
        \Gamma \der t = t' : T \qquad
        \Gamma \der u = u' : T
      }{\Gamma \der t =_T u = t' =_{T'} u'}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t = t' : T \qquad
      }{\Gamma \der \refl_t = \refl_{t'} : t =_T t}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der T = T' \qquad
        \Gamma \der t = t' : \isnType{n}{T}
      }{\Gamma \der \hsig{T,t} = \hsig{T';t'} : \nType{n}}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t = t' : \nType{n}
      }{\Gamma \der t \gettype = t' \gettype}
    \qquad
    \ru{\Gamma \der t = t' : \nType{n}
      }{\Gamma \der t \getproof = t' \getproof : \isnType{n}{T}}
  \)
  \end{center}

  \paradot{Conversion Rule}

  \begin{center}
  \(
    \ru{\Gamma \der t = t' : T \quad
        \Gamma \der T = T'
      }{\Gamma \der t = t' : T'}
  \)
  \end{center}

  \section{Algorithmic Equality}

  \paradot{Weak head normalization}

  Weak head normal forms (whnfs) are given by the following grammar:

  \begin{align*}
    \Whnf &\ni a,f,A,B,F &::=~&  \Pi x:U.T \mid \Sigma x:U.T \mid t =_T u \mid
                                 \nType{n} \\
        &&\mid~& n \mid \lambda x:U.t \mid (t;u) \mid \refl_t \mid \hsig{T;t} \\
    \Wne  &\ni n,N &::=~& x \mid n~u \mid n.1 \mid n.2
               \mid n \gettype \mid n \getproof
  \end{align*}

  Weak head reduction $t \rew a$ is given as follows:

  \begin{center}
  \(
    \ru{t \rew \lambda x:U.t' \qquad
        t'[u/x] \rew a
      }{t~u \rew a}
    \qquad
    \ru{t \rew (u;v) \qquad
        u \rew a
      }{t.1 \rew a}
    \qquad
    \ru{t \rew (u;v) \qquad
        v \rew a
      }{t.2 \rew a}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{t \rew \hsig{T;t'} \qquad
        T \rew A
      }{t \gettype \rew A}
    \qquad
    \ru{t \rew \hsig{T;t'} \qquad
        t' \rew a
      }{t \getproof \rew a}
    \qquad
    \ru{}{a \rew a}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{t \rew n
      }{t~u \rew n~u}
    \qquad
    \ru{t \rew n
      }{t.1 \rew n.1}
    \qquad
    \ru{t \rew n
      }{t.2 \rew n.2}
    \qquad
    \ru{t \rew n
      }{t \gettype \rew n \gettype}
    \qquad
    \ru{t \rew n
      }{t \getproof \rew n \getproof}
  \)
  \end{center}

  \paradot{Type-directed Equality}

  \begin{center}
  \(
    \ru{\Gamma \der t \iff t' : \red T
      }{\Gamma \der t \hiff t' : T}
    \qquad
    \ru{\Gamma, x:U \der t~x \hiff t'~x : V
      }{\Gamma \der t \iff t' : \Pi x:U.V}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t.1 \hiff t'.1 : U \qquad
        \Gamma \der t.2 \hiff t'.2 : V[t.1/x]
      }{\Gamma \der t \iff t' : \Sigma x:U.V}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t \gettype \hiff t' \gettype \qquad
        \Gamma \der t \getproof \hiff t' \getproof : \isnType{n}{t \gettype}
      }{\Gamma \der t \iff t' : \nType{n}}
  \)
  \end{center}

  \meta{We need observations for equality to define it, don't we?
  Otherwise we could just state equality for $\refl$.}

  \paradot{Structural Equality}

  \begin{center}
  \(
    \ru{\Gamma \der n \hsteq n' : T
      }{\Gamma \der n \steq n' :\ \red T}
    \qquad
    \ru{(x:T) \in \Gamma
      }{\Gamma \der x \hsteq x : T}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der n \steq n' : (x:U) \to V \qquad
        \Gamma \der u \hiff u' : U
      }{\Gamma \der n~u \hsteq n'~u' : V[u/x]}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der n \steq n' : \Sigma x:U.V
      }{\Gamma \der n.1 \hsteq n'.1 : U}
    \qquad
    \ru{\Gamma \der n \steq n' : \Sigma x:U.V
      }{\Gamma \der n.2 \hsteq n'.2 : V[n.1/x]}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der n \steq n' : \nType{m}
      }{\Gamma \der n \gettype \hsteq n' : \_}
    \qquad
    \ru{\Gamma \der n \steq n' : \nType{m}
      }{\Gamma \der n \getproof \hsteq n' \getproof : \isnType{m}{n \gettype}}
  \)
  \end{center}

  In the penultimate case, we return virtually nothing (anything actually) as
  type equality doesn't care much about the type returned by structural
  equality.

  \paradot{Type Equality}

  \begin{center}
  \(
    \ru{\Gamma \der \red T \iff \red T'
      }{\Gamma \der T \hiff T'}
    \qquad
    \ru{\Gamma \der U \hiff U' \qquad
        \Gamma, x:U \der V \hiff V'
      }{\Gamma \der \Pi x:U.V \iff \Pi x:U'.V'}
    \qquad
    \ru{\Gamma \der N \hsteq N' : \_
      }{\Gamma \der N \iff N'}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der U \hiff U' \qquad
        \Gamma, x:U \der V \hiff V'
      }{\Gamma \der \Sigma x:U.V \iff \Sigma x:U'.V'}
    \qquad
    \ru{}{\Gamma \der \nType{n} \iff \nType{n}}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der T \hiff T' \qquad
        \Gamma \der t \hiff t' : T \qquad
        \Gamma \der u \hiff u' : T
      }{\Gamma \der t =_T u \iff t' =_T u'}
  \)
  \end{center}

  \section{A Logical Relation for Soundness}

  \paradot{An Induction Measure}

  In order to define a logical relation, we define a hierarchy.
  In similar works, this hierarchy would be a semantic universe hierarchy but
  instead we want to interpret our types as $n$-Types whose semantics
  counterpart shall be noted $\Hu_n$.
  By recursion on $i \in \mathbb{N}$, we define
  $\Hu_n \subseteq \Whnf \times \mathcal{P}(\Whnf)$ as follows.

  \begin{center}
  \(
    \ru{}{(N, \Wne) \in \Hu_n}
    \qquad
    % \rux{}{(\nType{n}, \mid \Hu_n \mid) \in \Hu_m}{n < m}
    \rux{\forall T \in \widehat{\mid \Hu_n \mid},\ %
         (\isnType{n}{T}, \mathcal{F}(T)) \in \Hu_{-1}
       }{(\nType{n}, \bigoplus \mid \Hu_n \mid \mathcal{F}) \in \Hu_m
       }{n < m}
  \)
  \end{center}

  \begin{center}
  \(
    \rux{(U, \mathcal{A}) \in \widehat{\Hu_n} \qquad
        \forall u \in \widehat{\mathcal{A}},\ (V[u/x], \mathcal{F}(u)) \in \Hu_m
       }{(\Pi x:U.V, \Pi \mathcal{A} \mathcal{F}) \in \Hu_k
       }{n,m \le k}
  \)
  \end{center}

  \begin{center}
  \(
    \rux{(U, \mathcal{A}) \in \widehat{\Hu_n} \qquad
        \forall u \in \widehat{\mathcal{A}},\ (V[u/x], \mathcal{F}(u)) \in \Hu_m
       }{(\Sigma x:U.V, \Sigma \mathcal{A} \mathcal{F}) \in \Hu_k
       }{n,m \le k}
  \)
  \end{center}

  \meta{Here we also need to find a way to observe equalities to interperet
  the equaity type...}

  \noindent %
  Here, $\mathcal{A}$ denotes sets of expressions, $\mathcal{F}$ functions from
  expressions to set of expressions while
  $\widehat{\Hu_n} = \{ (T,\mathcal{A}) \mid (\red T, \mathcal{A}) \in \Hu_n \}$
  and $\mid \Hu_n \mid = \{ A \mid (A, \mathcal{A}) \in \Hu_n \text{ for some }
  \mathcal{A} \}$.
  $\widehat{\mathcal{A}} = \{ t \mid \red t \in \mathcal{A} \}$ is the closure
  of $\mathcal{A}$ by weak head expansion.
  The dependent function space is defined as
  $\Pi \mathcal{A} \mathcal{F} = \{ f \in \Whnf \mid \forall u \in
  \widehat{\mathcal{A}},\ f~u \in \mathcal{F}(u) \}$.
  The dependent sum space is defined as
  $\Sigma \mathcal{A} \mathcal{F} = \{ f \in \Whnf \mid f.1 \in \mathcal{A}
  \text{ and } f.2 \in \mathcal{F}(f.1) \}$.
  A slightly different version of dependent sum space is defined as
  $\bigoplus \mathcal{A} \mathcal{F} = \{ f \in \Whnf \mid f \gettype \in
  \mathcal{A} \text{ and } f \getproof \in \mathcal{F}(f \gettype) \}$.

  Throughout this paper, the induction measure $A \in \nType{n}$ shall mean the
  minimum height of a derivation of $(A, \mathcal{A}) \in \Hu_n$ for some
  $\mathcal{A}$.
  Note that we also have that $A \in \nType{n}$ is smaller than
  $\nType{n} \in \nType{m}$.
  We also write $A \in \hType$ for $A \in \nType{n}$ for some $n$.

  \paradot{A Krikpe Logical Relation}
  Let $\Gamma \der t :=: t' : T$ stand for the conjunction of propositions
  \begin{itemize}
    \item $\Gamma \der t,t' : T$ and
    \item $\Gamma \der t = t' : T$.
  \end{itemize}
  %
  By induction on $A \in \hType$, we define two Kripke relations:
  \begin{itemize}
    \item $\Gamma \der A \Sr A'$
    \item $\Gamma \der a \Sr a' : A$
  \end{itemize}
  together with their respective closures $\hSr$.
  We define them in rule form for better readability meaning we have to see the
  conclusion to be defined as the conjunction of the premises.

  \begin{center}
  \(
    \ru{\Gamma \der N :=: N'
      }{\Gamma \der N \Sr N'}
    \qquad
    \ru{\Gamma \der n :=: n' : N
      }{\Gamma \der n \Sr n' : N}
    \qquad
    \ru{\der \Gamma
      }{\Gamma \der \nType{m} \Sr \nType{m}}
  \)
  \end{center}

  \begin{center}
  \(
    \tru{\Gamma \der U \hSr U'
       }{\forall \Delta \le \Gamma,\ \Delta \der u \hSr u' : U \gives
         \Delta \der V[u/x] \hSr V'[u'/x]
       }{\Gamma \der \Pi x:U.V :=: \Pi x:U'.V'
       }{\Gamma \der \Pi x:U.V \Sr \Pi x:U'.V'}
  \)
  \end{center}

  \begin{center}
  \(
    \dru{\forall \Delta \le \Gamma,\ \Delta \der u \hSr u' : U \gives
         \Delta \der f~u \hSr f'~u' : V[u/x]
       }{\Gamma \der f :=: f' : \Pi x:U.V
       }{\Gamma \der f \Sr f' : \Pi x:U.V}
  \)
  \end{center}

  \begin{center}
  \(
    \tru{\Gamma \der U \hSr U'
       }{\forall \Delta \le \Gamma,\ \Delta \der u \hSr u' : U \gives
         \Delta \der V[u/x] \hSr V'[u'/x]
       }{\Gamma \der \Sigma x:U.V :=: \Sigma x:U'.V'
       }{\Gamma \der \Sigma x:U.V \Sr \Sigma x:U'.V'}
  \)
  \end{center}

  \begin{center}
  \(
    \dru{\Gamma \der f.1 \hSr f'.1 : U \qquad
         \Gamma \der f.2 \hSr f'.2 : V[f.1/x]
       }{\Gamma \der f :=: f' : \Sigma x:U.V
       }{\Gamma \der f \Sr f' : \Sigma x:U.V}
  \)
  \end{center}

  \begin{center}
  \(
    \dru{\Gamma \der f \gettype \hSr f' \gettype \qquad
         \Gamma \der f \getproof \hSr f' \getproof : \isnType{m}{f \gettype}
       }{\Gamma \der f :=: f' : \nType{m}
       }{\Gamma \der f \Sr f' : \nType{m}}
  \)
  \end{center}

  \meta{There is currently a problem, how can we be sure that
  $f \gettype \in \nType{m}$?}

  \begin{center}
  \(
    \qru{T \rew A \qquad
         \Gamma \der T = A
       }{t \rew a \qquad
         \Gamma \der t = a : A \qquad
         \Gamma \der t' = a' : A \qquad
         t' \rew a'
       }{\Gamma \der a \Sr a' : A
       }{\Gamma \der t :=: t' : T
       }{\Gamma \der t \hSr t' : T}
  \)
  \end{center}

\end{document}
