\documentclass[a4paper,english]{lipics-utf8x}

\usepackage[T1]{fontenc} %

\usepackage{amsmath, amssymb, amsfonts, stmaryrd}
\usepackage{pifont}
\PrerenderUnicode{é} % For the author names in the heading

% Add some colors
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage{hyperref}
\hypersetup{
 linktocpage,
 colorlinks,
 citecolor=BlueViolet,
 filecolor=red,
 linkcolor=Blue,
 urlcolor=BrickRed
}

\usepackage{graphicx}
\usepackage{placeins}

% Meta comment
\newcommand\meta[1]{\noindent\textcolor{blue}{\emph{#1}}}

% Include the macro file
\input{macros}

% Title and so...
\title{$n$-Types can stay in their home universe}
\author[1]{Théo Winterhalter}

\begin{document}

  \maketitle

  \begin{abstract}
    We'll try to define a system with no universe hierarchy but with
    $n$-Types, hopefully showing it's consistent and has a decidable type
    checking.
  \end{abstract}

  \section{Syntax}

  \[
    \begin{array}{l@{~}l@{~}l@{~}r@{~}l@{\quad}l}
      \Var  & \ni & x,y,X,Y \\
      \Exp  & \ni & t,u,T,U & ::= & \Pi x:U.T \mid \Sigma x:U.T \mid
                                    \nType{n} \\
                         &&& \mid & x \mid \lambda x:U.t \mid t~u
                               \mid (t;u) \mid t.1 \mid t.2 \\
                         &&& \mid & {<} T ; t {>}
                               \mid t \gettype \mid t \getproof \\
      \Ctx  & \ni & \Gamma  & ::= & \cdot \mid \Gamma, x:T \\
    \end{array}
  \]

  \section{Typing Rules}

  We give ourselves basic dependent type theory with $\Pi$-types and
  $\Sigma$-types, as well as the indentity types necessary to define the
  $n$-Types.
  This theory doesn't have the usual universes that one require to ensure
  consistency. The goal is to prove that they are unnecessary as long as you
  remain in the realm of $n$-Types (finite homotopy complexity).

  \begin{center}
  \(
    \ru{}{\der \cdot}
    \qquad
    \ru{\Gamma \der T \type \qquad
        x \notin \Gamma
      }{\der \Gamma, x : T}
    \qquad
    \ru{\der \Gamma \qquad
        (x : T) \in \Gamma
      }{\Gamma \der x : T}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t : \Pi x:A.B \qquad
        \Gamma \der t' : A
      }{\Gamma \der t\ t' : B[t'/x]}
    \qquad
    \ru{\Gamma \der A \type \qquad
        \Gamma, x:A \der B \type
      }{\Gamma \der \Pi x:A.B \type}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der \Pi x:A.B : s \qquad
        \Gamma, x:A \der t : B
      }{\Gamma \der \lambda x:A.t : \Pi x:A.B}
    \qquad
    \ru{\Gamma \der t : \Sigma x:A.B
      }{\Gamma \der t.1 : A}
    \qquad
    \ru{\Gamma \der t : \Sigma x:A.B
      }{\Gamma \der t.2 : B[t.1/x]}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t : A \qquad
        \Gamma \der t' : B[t/x]
      }{\Gamma \der (t ; t') : \Sigma x:A.B}
    \qquad
    \ru{\Gamma \der A \type \qquad
        \Gamma, x:A \der B \type
      }{\Gamma \der \Sigma x:A.B \type}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der T \type \qquad
        \Gamma \der t,t' : T
      }{\Gamma \der t =_T t' \type}
    \qquad
    \ru{\Gamma \der t : A
      }{\Gamma \der \refl_t : t =_T t}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t : A \qquad
        \Gamma \der B \type \qquad
        \Gamma \der A = B
      }{\Gamma \der t : B}
  \)
  \end{center}

  \meta{TODO: Add an elimination rule for equality.}

  \noindent %
  We then add the rules regarding the $n$-Types, giving us base
  types.
  Basically we are defining types that couldn't be defined without
  quantification on a universe. Our purpose is then to prove
  that all of these $n$-Types can live in the smalleest universe:
  indeed, $\Gamma \der T \type$ can be seen as
  $\Gamma \der T : \Type_0$ in a PTS with smallest universe
  $\Type_0$.

  For this we define $\isnType{n}{T}$ as a shortcut for the following:

  \[
  \begin{array}{l@{~}l}
    \isnType{(-2)}{T}  & := \Sigma x:T. \Pi y:T. x =_T y \\
    \isnType{(n+1)}{T} & := \Pi x:T. \Pi y:T. \isnType{n}{x =_T y}
  \end{array}
  \]

  We also add $\nType{n}$ as a base type for quantification
  purposes. This is basically a $\Sigma$-type except that it is
  defined on the whole universe.

  \begin{center}
  \(
    \ru{}{\Gamma \der \nType{n} \type}
    \qquad
    \ru{\Gamma \der T \type \qquad
        \Gamma \der h : \isnType{n}{T}
      }{\Gamma \der {<} T ; h {>} : \nType{n}}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t : \nType{n}
      }{\Gamma \der t \gettype \type}
    \qquad
    \ru{\Gamma \der t : \nType{n}
      }{\Gamma \der t \getproof : \isnType{n}{t \gettype}}
  \)
  \end{center}

  As one can guess, both $\_ \gettype$ and $\_ \getproof$ are respectively first
  and second projections.

  \meta{Shouldn't homotopy level be a part of the syntax? We need to define them
  somewhere, and the user might want to do a case analysis on them.}

  \section{Algorithmic Equality}

  \paradot{Weak head normalization}

  Weak head normal forms (whnfs) are given by the following grammar:

  \begin{align*}
    \Whnf &\ni r,f,A,B,F &::=~&  \Pi x:U.T \mid \Sigma x:U.T \mid
                                 \nType{n} \\
        &&\mid~& n \mid \lambda x:U.t \mid (t;u) \mid {<}T;t{>} \\
    \Wne  &\ni n,N &::=~& x \mid n~u \mid n.1 \mid n.2
               \mid n \gettype \mid n \getproof
  \end{align*}

  Weak head reduction $t \rew a$ is given as follows:

  \begin{center}
  \(
    \ru{t \rew \lambda x:U.t' \qquad
        t'[u/x] \rew a
      }{t~u \rew a}
    \qquad
    \ru{t \rew (u;v) \qquad
        u \rew a
      }{t.1 \rew a}
    \qquad
    \ru{t \rew (u;v) \qquad
        v \rew a
      }{t.2 \rew a}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{t \rew {<}T;t'{>} \qquad
        T \rew A
      }{t \gettype \rew A}
    \qquad
    \ru{t \rew {<}T;t'{>} \qquad
        t' \rew a
      }{t \getproof \rew a}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{t \rew n
      }{t~u \rew n~u}
    \qquad
    \ru{t \rew n
      }{t.1 \rew n.1}
    \qquad
    \ru{t \rew n
      }{t.2 \rew n.2}
    \qquad
    \ru{t \rew n
      }{t \gettype \rew n \gettype}
    \qquad
    \ru{t \rew n
      }{t \getproof \rew n \getproof}
  \)
  \end{center}

  \paradot{Type-directed Equality}

  \begin{center}
  \(
    \ru{\Gamma \der t \iff t' : \red T
      }{\Gamma \der t \hiff t' : T}
    \qquad
    \ru{\Gamma, x:U \der t~x \hiff t'~x : V
      }{\Gamma \der t \iff t' : \Pi x:U.V}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t.1 \hiff t'.1 : U \qquad
        \Gamma \der t.2 \hiff t'.2 : V[t.1/x]
      }{\Gamma \der t \iff t' : \Sigma x:U.V}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der t \gettype \hiff t' \gettype \qquad
        \Gamma \der t \getproof \hiff t' \getproof : \isnType{n}{t \gettype}
      }{\Gamma \der t \iff t' : \nType{n}}
  \)
  \end{center}

  \paradot{Structural Equality}

  \begin{center}
  \(
    \ru{\Gamma \der n \hsteq n' : T
      }{\Gamma \der n \steq n' :\ \red T}
    \qquad
    \ru{(x:T) \in \Gamma
      }{\Gamma \der x \hsteq x : T}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der n \steq n' : (x:U) \to V \qquad
        \Gamma \der u \hiff u' : U
      }{\Gamma \der n~u \hsteq n'~u' : V[u/x]}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der n \steq n' : \Sigma x:U.V
      }{\Gamma \der n.1 \hsteq n'.1 : U}
    \qquad
    \ru{\Gamma \der n \steq n' : \Sigma x:U.V
      }{\Gamma \der n.2 \hsteq n'.2 : V[n.1/x]}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der n \steq n' : \nType{m}
      }{\Gamma \der n \gettype \hsteq n' : \_}
    \qquad
    \ru{\Gamma \der n \steq n' : \nType{m}
      }{\Gamma \der n \getproof \hsteq n' \getproof : \isnType{m}{n \gettype}}
  \)
  \end{center}

  In the penultimate case, we return virtually nothing (anything actually) as
  type equality doesn't care much about the type returned by structural
  equality.

  \paradot{Type Equality}

  \begin{center}
  \(
    \ru{\Gamma \der \red T \iff \red T'
      }{\Gamma \der T \hiff T'}
    \qquad
    \ru{\Gamma \der U \hiff U' \qquad
        \Gamma, x:U \der V \hiff V'
      }{\Gamma \der \Pi x:U.V \iff \Pi x:U'.V'}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der U \hiff U' \qquad
        \Gamma, x:U \der V \hiff V'
      }{\Gamma \der \Sigma x:U.V \iff \Sigma x:U'.V'}
    \qquad
    \ru{}{\Gamma \der \nType{n} \iff \nType{n}}
  \)
  \end{center}

  \begin{center}
  \(
    \ru{\Gamma \der N \hsteq N' : \_
      }{\Gamma \der N \iff N'}
  \)
  \end{center}

  \paradot{An Induction Measure}

  In order to define a logical relation, we define a hierarchy.
  In similar works, this hierarchy would be a semantic universe hierarchy but
  instead we want to interpret our types as $n$-Types whose semantics
  counterpart shall be noted $\Hu_n$.

  \begin{center}
  \(
    \ru{}{(N, \Wne) \in \Hu_n}
    \qquad
    \rux{}{(\nType{n}, \mid \Hu_n \mid) \in \Hu_m}{n < m}
  \)
  \end{center}

  \begin{center}
  \(
    \rux{(U, \mathcal{A}) \in \widehat{\Hu_n} \qquad
        \forall u \in \widehat{\mathcal{A}},\ (V[u/x], \mathcal{F}(u)) \in \Hu_m
       }{(\Pi x:U.V, \Pi \mathcal{A} \mathcal{F}) \in \Hu_k
       }{n,m \le k}
  \)
  \end{center}

  \begin{center}
  \(
    \rux{(U, \mathcal{A}) \in \widehat{\Hu_n} \qquad
        \forall u \in \widehat{\mathcal{A}},\ (V[u/x], \mathcal{F}(u)) \in \Hu_m
       }{(\Sigma x:U.V, \Sigma \mathcal{A} \mathcal{F}) \in \Hu_k
       }{n,m \le k}
  \)
  \end{center}

\end{document}
